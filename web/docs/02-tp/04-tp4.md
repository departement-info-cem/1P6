# ğŸ§ª TP4 â€“ DÃ©mineur

---

## ğŸ¯ Objectif du TP4

RÃ©aliser un **jeu de DÃ©mineur** en **C# Windows Forms**.

Ce travail te fera passer de la console aux **interfaces graphiques (GUI)** tout en- Cliquer sur **Nouvelle partie** affiche un message.  
- Cliquer sur **Quitter** ferme l'application.  
- Changer de difficultÃ© met Ã  jour `colonnesGrille`, `lignesGrille` et `nombreMines` et affiche un message de confirmation.investissant les notions de tableaux 2D, de boucles, de conditions et de lecture/Ã©criture de fichiers.

### FonctionnalitÃ©s attendues

- ğŸ§© **Grille de jeu** composÃ©e de boutons (une case = un bouton)
- ğŸšï¸ **Trois niveaux de difficultÃ©** :  
  - *Facile* â†’ **9 x 9** avec **10 mines**  
  - *Moyen* â†’ **16 x 16** avec **40 mines**  
  - *Difficile* â†’ **30 x 16** avec **99 mines**  
- ğŸ•’ **ChronomÃ¨tre** pour mesurer le temps de la partie
- ğŸ† **Top 5 meilleurs temps** pour chaque niveau, sauvegardÃ©s dans un **fichier texte**
- ğŸ§¾ **FenÃªtre de saisie du nom** lorsquâ€™un nouveau temps entre dans le **Top 5**
- ğŸ“ Lecture/Ã©criture des meilleurs rÃ©sultats
- ğŸ“‹ Barre de menu
- ğŸ“ **Redimensionnement automatique** de la fenÃªtre selon la taille de la grille (9x9, 16x16, 30x16)

---

## ğŸ§‘â€ğŸ’» CrÃ©ation du projet Windows Forms

:::tip Note
CrÃ©er un projet **Application Windows Forms (.NET)**.

- Langage : **C#**  
- Nom du projet : par exemple `TP4_Demineur`
:::

## Ã‰tape 1 â€” PrÃ©parer la structure du projet

### ğŸ¯ Objectif

Mettre en place les **variables globales** et les premiers Ã©lÃ©ments nÃ©cessaires au DÃ©mineur :

- Les **tableaux 2D** pour reprÃ©senter le jeu
- Les constantes liÃ©es aux niveaux de difficultÃ©
- Une fonction `Tests()` pour vÃ©rifier progressivement le comportement du programme (comme aux TP2 et TP3).

---

### 1ï¸âƒ£ Variables globales et constantes

Ajouter dans ton fichier `Form1.cs` (Ã  lâ€™intÃ©rieur de la classe `Form1`, mais **en dehors** des mÃ©thodes) :

```csharp
// DifficultÃ©s
const int DIFF_FACILE_COLONNES = 9;
const int DIFF_FACILE_LIGNES = 9;
const int DIFF_FACILE_MINES = 10;

const int DIFF_MOYEN_COLONNES = 16;
const int DIFF_MOYEN_LIGNES = 16;
const int DIFF_MOYEN_MINES = 40;

const int DIFF_DIFFICILE_COLONNES = 30;
const int DIFF_DIFFICILE_LIGNES = 16;
const int DIFF_DIFFICILE_MINES = 99;

// Valeurs pour le contenu des cases
const int CASE_VIDE = 0;       // aucune mine autour
const int CASE_MINE = -1;      // case contenant une mine

// Grilles de jeu
int[,] grilleMines;           // contient mines / nombres
bool[,] grilleRevelee;        // indique si une case est rÃ©vÃ©lÃ©e
Button[,] grilleBoutons;      // boutons affichÃ©s Ã  l'Ã©cran

// ParamÃ¨tres de la partie en cours
int colonnesGrille = DIFF_FACILE_COLONNES;
int lignesGrille = DIFF_FACILE_LIGNES;
int nombreMines = DIFF_FACILE_MINES;

// ChronomÃ¨tre
DateTime heureDebut;
```

---

### 2ï¸âƒ£ MÃ©thode `Tests()`

Ajoute une mÃ©thode simple pour tester progressivement le contenu des tableaux.

```csharp
private void Tests()
{
    // Exemple : afficher quelques infos dans la console de sortie
    Console.WriteLine($"Taille : {colonnesGrille} x {lignesGrille}");
    Console.WriteLine($"Nombre de mines : {nombreMines}");
}
```

Appelle `Tests()` depuis le constructeur de `Form1` aprÃ¨s `InitializeComponent()` :

```csharp
public Form1()
{
    InitializeComponent();
    Tests();
}
```

:::tip OÃ¹ voir `Console.WriteLine` ?
Dans un projet Windows Forms, tu peux ouvrir la **fenÃªtre de sortie** de Visual Studio pour voir le texte envoyÃ© par `Console.WriteLine`.
:::

### âœ… RÃ©sultat attendu

- Le projet **compile** sans erreur.  
- Au dÃ©marrage, la fenÃªtre sâ€™ouvre et des informations de test sâ€™affichent dans la sortie.

---

## Ã‰tape 2 â€” CrÃ©er la barre de menu

### ğŸ¯ Objectif

Ajouter une **barre de menus** qui donnera accÃ¨s aux principales fonctionnalitÃ©s du jeu.

---

### 1ï¸âƒ£ Ajouter un `MenuStrip`

Dans le concepteur Windows Forms :

1. Glisser un contrÃ´le **`MenuStrip`** sur le formulaire.
2. Renommer-le (propriÃ©tÃ© `Name`) en `menuPrincipal`.
3. Ajouter les menus suivants :
   - `Jeu`
     - `Nouvelle partie` (raccourci : Ctrl+N)
     - `Quitter` (raccourci : Ctrl+Q)
   - `DifficultÃ©`
     - `Facile`
     - `Moyenne`
     - `Difficile`
   - `Meilleurs temps`
     - `Afficher les meilleurs temps`

Pour chaque Ã©lÃ©ment, tu peux double-cliquer pour gÃ©nÃ©rer un gestionnaire dâ€™Ã©vÃ¨nement `Click`.

---

### 2ï¸âƒ£ Code minimal pour les menus

Exemple de **pseudo-code** pour les gestionnaires d'Ã©vÃ©nements dans `Form1` :

```text
Quand on clique sur "Nouvelle partie" :
    â†’ (plus tard) lancer l'initialisation de la grille et commencer une partie

Quand on clique sur "Quitter" :
    â†’ fermer la fenÃªtre principale de l'application

Quand on clique sur "Facile" :
    â†’ fixer la taille de la grille
    â†’ fixer le nombre de mines
    â†’ dÃ©cocher les difficultÃ©s
    â†’ cocher "Facile"
    â†’ (prochaine Ã©tape) rÃ©initialiser la grille

Quand on clique sur "Moyenne" :
    â†’ fixer la taille de la grille
    â†’ fixer le nombre de mines
    â†’ dÃ©cocher les difficultÃ©s
    â†’ cocher "Moyenne"
    â†’ (prochaine Ã©tape) rÃ©initialiser la grille

Quand on clique sur "Difficile" :
    â†’ fixer la taille de la grille
    â†’ fixer le nombre de mines
    â†’ dÃ©cocher les difficultÃ©s
    â†’ cocher "Moyenne"
    â†’ (prochaine Ã©tape) rÃ©initialiser la grille

Quand on clique sur "Afficher les meilleurs temps" :
    â†’ (plus tard) ouvrir une fenÃªtre ou un message qui montrera les meilleurs temps
```

### âœ… RÃ©sultat attendu

- Cliquer sur **Nouvelle partie** affiche pour l'instant un comportement simple (par exemple un message) ou ne fait rien si la logique n'est pas encore codÃ©e.  
- Cliquer sur **Quitter** ferme lâ€™application.  
- Changer de difficultÃ© mettra Ã  jour les paramÃ¨tres de la grille (`colonnes`, `lignes`, `nombre de mines`).

---

## Ã‰tape 3 â€” GÃ©nÃ©rer dynamiquement la grille de boutons

### ğŸ¯ Objectif

CrÃ©er une **grille de boutons** reprÃ©sentant le plateau du DÃ©mineur.

Chaque case du tableau correspond Ã  **un bouton** positionnÃ© dynamiquement sur le formulaire.

---

### 1ï¸âƒ£ PrÃ©parer une fonction `InitialiserGrille()`

Dans `Form1.cs` :

```text
Fonction InitialiserGrille :
    â†’ Initialiser grilleMines Ã  la bonne taille
    â†’ Initialiser grilleRevelee Ã  la bonne taille
    â†’ Initialiser grilleBoutons Ã  la bonne taille

    â†’ Effacer tous les contrÃ´les du formulaire
    â†’ RÃ©ajouter la barre de menu en haut

    â†’ DÃ©finir la taille d'une case en pixels (par ex. 30)
    â†’ DÃ©finir une marge autour de la grille (par ex. 10)

    Pour chaque ligne de 0 Ã  nombre de lignes - 1 :
        Pour chaque colonne de 0 Ã  nombre de colonnes - 1 :
            â†’ CrÃ©er un nouveau bouton
            â†’ Fixer sa largeur et sa hauteur Ã  la taille d'une case

            â†’ Calculer sa position en X en fonction de la colonne, de la taille de la case et de la marge
            â†’ Calculer sa position en Y en fonction de la ligne, de la taille de la case, de la marge et de la hauteur du menu

            â†’ Associer au bouton sa position (ligne, colonne) pour la retrouver lors du clic
            â†’ Brancher le gestionnaire d'Ã©vÃ©nement de clic (Bouton_Click)

            â†’ Ajouter le bouton sur le formulaire
            â†’ Ajouter le bouton Ã  grilleBoutons

    â†’ Ajuster la largeur de la fenÃªtre en fonction du nombre de colonnes et de la taille des cases
    â†’ Ajuster la hauteur de la fenÃªtre en fonction du nombre de lignes, de la taille des cases et de la hauteur du menu
```

Ajoute ensuite une mÃ©thode pour gÃ©rer le clic sur une case (en pseudoâ€‘code) :

```text
Quand on clique sur un bouton de la grille (Bouton_Click) :
    â†’ RÃ©cupÃ©rer la case cliquÃ©e (le bouton qui a envoyÃ© l'Ã©vÃ©nement)
    â†’ Lire, dans les informations associÃ©es au bouton, la position (ligne, colonne)
    â†’ Pour lâ€™instant : afficher la position de la case cliquÃ©e sous la forme "(ligne, colonne)"
    â†’ (Ã  la prochaine Ã©tape) appeler une fonction qui rÃ©vÃ©lera la case dans la grille du dÃ©mineur
```

### âœ… RÃ©sultat attendu

- Cliquer sur **Nouvelle partie** â†’ la fenÃªtre affiche une grille de boutons en fonction de la difficultÃ©.  
- La taille de la fenÃªtre **change** correctement si tu passes de *Facile* Ã  *Difficile* (9x9 â†’ 30x16).  
- Cliquer sur une case montre un message avec `(ligne, colonne)`.

---

## Ã‰tape 4 â€” Placer les mines et calculer les nombres

### ğŸ¯ Objectif

- Placer alÃ©atoirement les **mines** dans `grilleMines`.
- Calculer, pour chaque case non-mine, le **nombre de mines adjacentes**.

---

### 1ï¸âƒ£ Fonction `PlacerMines()`

```text
Fonction PlacerMines :
    â†’ Initialiser un compteur Â« minesPlacees Â» Ã  0

    Tant que Â« minesPlacees Â» est strictement infÃ©rieur Ã  Â« nombreMines Â» :
        â†’ Choisir au hasard une ligne entre 0 et lignesGrille - 1
        â†’ Choisir au hasard une colonne entre 0 et colonnesGrille - 1

        â†’ Si la case (ligne, colonne) ne contient pas dÃ©jÃ  une mine dans le tableau Â« grilleMines Â» :
            â†’ Placer une mine dans cette case (mettre CASE_MINE dans grilleMines[ligne, colonne])
            â†’ IncrÃ©menter Â« minesPlacees Â» de 1
```

---

### 2ï¸âƒ£ Fonction `CalculerNombreMines()`

Pour chaque case, on regarde les **8 voisins** autour dâ€™elle pour trouver le nombre de mines qui lui touche :

|         |  dc = -1  |   dc = 0   | dc = +1 |
|---------|----------:|-----------:|--------:|
| dl = -1 |  (-1,-1)  |   (-1,0)   |  (-1,1) |
| dl = 0  |  (-1,0)   |            |  (0,1)  |
| dl = +1 |  (-1,1)   |   (-1,1)   |  (1,1)  |

- `dl` â†’ DÃ©calage de ligne
- `dc` â†’ DÃ©calage de colonne
- `nl = ligne + dl` â†’ ligne voisine  
- `nc = colonne + dc` â†’ colonne voisine 

Exemple pour une case Ã  la position (4,2) on veut valider si le coin en haut Ã  gauche contient une mine
```csharp
ligne = 4;
colonne = 2;
dl = -1;
dc = -1;
nl = ligne + dl = 4 - 1 = 3;
nc = colonne + dc = 2 - 1 = 1;
```
On valider donc si (nl,nc) â†’ (3,1) contient une mine

On ne compte la case voisine que si `(nl, nc)` reste **dans les bornes du tableau**.
```text
Fonction CalculerNombreMines :

    Pour chaque ligne de 0 Ã  lignesGrille - 1 :
        Pour chaque colonne de 0 Ã  colonnesGrille - 1 :

            â†’ Si la case (ligne, colonne) contient une mine dans grilleMines :
                  passer Ã  la case suivante (ne rien calculer pour cette case)

            â†’ Sinon :
                  initialiser un compteur Â« nbMines Â» Ã  0

                  Pour chaque dÃ©calage de ligne dl allant de -1 Ã  +1 :
                      Pour chaque dÃ©calage de colonne dc allant de -1 Ã  +1 :

                          â†’ si (dl, dc) vaut (0, 0), ignorer (câ€™est la case elleâ€‘mÃªme)

                          â†’ calculer nl = ligne + dl
                          â†’ calculer nc = colonne + dc

                          â†’ si (nl, nc) est Ã  lâ€™intÃ©rieur de la grille:
                                â†’ si la case (nl, nc) contient une mine dans grilleMines :
                                      augmenter Â« nbMines Â» de 1

                  â†’ aprÃ¨s avoir regardÃ© toutes les cases voisines,
                    enregistrer Â« nbMines Â» dans grilleMines[ligne, colonne]
```

---

### 3ï¸âƒ£ Mettre Ã  jour `InitialiserGrille()`

Ajouter les appels Ã  nos 2 fonctions et enregistrer l'heure de dÃ©but du jeu pour pouvoir calculer le temps.

```csharp
private void InitialiserGrille()
{
    //...

    PlacerMines();
    CalculerNombreMines();

    heureDebut = DateTime.Now;
    //...
}
```

### âœ… RÃ©sultat attendu

Ajoute ceci dans `Tests()` temporairement :

```csharp
InitialiserGrille();

string lignes = "";

for (int i = 0; i < lignesGrille; i++)
{
    
    for (int j = 0; j < colonnesGrille; j++)
    {
        lignes += grilleMines[i, j].ToString().PadLeft(3);
    }
    lignes += "\r\n";
}

MessageBox.Show(lignes);
```

- Tu dois voir dans la fenÃªtre modal une **grille de nombres** :  
  - `-1` pour les mines  
  - `0,1,2,...` pour les nombres de mines adjacentes.

---

## Ã‰tape 5 â€” RÃ©vÃ©ler une case (logique de base)

### ğŸ¯ Objectif

- Quand on clique sur un bouton, rÃ©vÃ©ler la **valeur de la case** (mine, nombre, vide).  
- Marquer la case comme **rÃ©vÃ©lÃ©e** dans `grilleRevelee`.

---

### 1ï¸âƒ£ Fonction `RevelerCase(int ligne, int colonne)`

```text
Fonction RevelerCase(ligne, colonne) :
    â†’ Si la ligne ou la colonne est en dehors des limites de la grille :
          arrÃªter la fonction (return)
    
    â†’ Si la case (ligne, colonne) est dÃ©jÃ  rÃ©vÃ©lÃ©e dans grilleRevelee :
          arrÃªter la fonction (return)
    
    â†’ Marquer la case comme rÃ©vÃ©lÃ©e dans grilleRevelee[ligne, colonne]
    
    â†’ RÃ©cupÃ©rer le bouton qui vient d'Ãªtre cliquÃ© dans grilleBoutons
    
    â†’ Si il y a une mine sur la case :
            afficher "ğŸ’£" sur le bouton
            mettre le fond en rouge
            (la gestion de la dÃ©faite sera ajoutÃ©e Ã  l'Ã©tape suivante)
    
    â†’ Sinon, si la case est vide :
            ne rien afficher sur le bouton (Text = "")
            mettre le fond en gris clair
    
    â†’ Sinon (c'est un nombre) :
            afficher le nombre sur le bouton
            mettre le fond en blanc
```

### 2ï¸âƒ£ Utiliser `RevelerCase` dans `Bouton_Click`

```csharp
private void Bouton_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    Point position = (Point)btn.Tag;

    RevelerCase(position.X, position.Y);
}
```

### âœ… RÃ©sultat attendu

- Cliquer sur une case affiche :  
    - `ğŸ’£` sur un fond rouge (ou autre couleur selon vos goÃ»t) si câ€™est une mine  
    - un chiffre sur fond gris si câ€™est une case numÃ©rotÃ©e  
    - rien, `""`, (sur fond gris) si câ€™est vide.


## Ã‰tape 6 â€” GÃ©rer la fin de partie (victoire / dÃ©faite)

### ğŸ¯ Objectif

- **Perdre** quand on clique sur une mine.  
- **Gagner** quand toutes les cases non-mines sont rÃ©vÃ©lÃ©es.

---

### 1ï¸âƒ£ DÃ©faite : clic sur une mine

- Modifie `RevelerCase` pour gÃ©rer la fin de partie si câ€™est une mine :
    - Afficher un message de dÃ©faite tel que "ğŸ’£â›ï¸ Oups c'Ã©tait une mine ! ğŸ’¥ "
    - Appeler `RevelerTout()` et terminer la partie

- CrÃ©e une fonction `RevelerTout` qui affichera toutes les cases de la grille lorsque l'on clic sur une mine :

```text
Fonction RevelerTout() :

    â†’ Pour chaque ligne de 0 Ã  lignesGrille - 1 :
          Pour chaque colonne de 0 Ã  colonnesGrille - 1 :

              â†’ RÃ©cupÃ©rer le bouton correspondant dans grilleBoutons
              â†’ DÃ©sactiver le bouton

              â†’ Si la case contient une mine :
                    afficher "ğŸ’£" sur le bouton
                    mettre le fond en rouge (ou une autre couleur pour les mines non cliquÃ©es)

              â†’ Sinon, si la case est vide :
                    ne rien afficher (texte vide)
                    mettre le fond en gris clair

              â†’ Sinon (c'est un nombre) :
                    afficher le nombre sur le bouton
                    mettre le fond gris

              â†’ Marquer la case comme rÃ©vÃ©lÃ©e dans grilleRevelee[ligne, colonne]
```

---

### 2ï¸âƒ£ Victoire : toutes les cases non-mines rÃ©vÃ©lÃ©es
- Nous avons dÃ©jÃ  initialisÃ© l'heure de dÃ©but de la partie
```csharp
private void InitialiserGrille()
{
    //...
    heureDebut = DateTime.Now;
    //...
}
```

- Ajouter une fonction `VerifierVictoire()` :

```text
Fonction VerifierVictoire :

    Pour chaque ligne de 0 Ã  lignesGrille - 1 :
        Pour chaque colonne de 0 Ã  colonnesGrille - 1 :

            â†’ Si la case (ligne, colonne) ne contient PAS une mine
              ET que la case n'est PAS rÃ©vÃ©lÃ©e dans grilleRevelee :

                  â†’ retourner faux (il reste encore au moins une case sÃ»re Ã  rÃ©vÃ©ler)
            â†’ Si la case (ligne, colonne) ne contient une mine
              ET que la case EST rÃ©vÃ©lÃ©e dans grilleRevelee :

                  â†’ retourner faux (Le joueur a rÃ©vÃ©lÃ© une mine, il a perdu)

    â†’ Si on a terminÃ© toutes les cases sans trouver de case sÃ»re non rÃ©vÃ©lÃ©e :
          retourner vrai (toutes les cases sans mine sont rÃ©vÃ©lÃ©es)
```

- Ajouter Ã  la fin de `RevelerCase` la vÃ©rification de la victoire:
- Afficher un message Ã  l'utilisateur et Initialiser une nouvelle partie

```text
â†’ Valider si c'est une victoire ou non avec `VerifierVictoire()`
â†’ Si c'est une victoire :
    â†’ Calculer la durÃ©e de la partie (TimeSpan duree = DateTime.Now - heureDebut;)
    â†’ Afficher un MessageBox.Show($"ğŸ‰ Victoire ! Temps : {duree.TotalSeconds:F1} secondes");
    â†’ DÃ©marrer une nouvelle partie
```

### âœ… RÃ©sultat attendu

- Clic sur une mine â†’ message de dÃ©faite + plus aucune rÃ©action aux clics.  
- RÃ©vÃ©ler toutes les cases sans mine â†’ message de victoire avec le temps.

---

## Ã‰tape 7 â€” Sauvegarder les meilleurs temps

### ğŸ¯ Objectif

- Sauvegarder les **5 meilleurs temps** par niveau de difficultÃ© dans un **fichier texte**.  
- Lire ce fichier au dÃ©marrage.  
- Demander le **nom du joueur** quand un nouveau temps entre dans le Top 5.

---

### 1ï¸âƒ£ Format des fichiers

Tu peux crÃ©er un fichier par difficultÃ©, par exemple :

- `scores_facile.txt`
- `scores_moyen.txt`
- `scores_difficile.txt`

Format proposÃ© (un score par ligne) :

```text
NomJoueur;TempsEnSecondes
Alice;35,4
Bob;42,8
```

---

### 2ï¸âƒ£ Lire les scores (`StreamReader`)

```csharp
private List<(string nom, double temps)> LireScores(string cheminFichier)
{
    List<(string nom, double temps)> scores = new List<(string nom, double temps)>();

    if (!File.Exists(cheminFichier))
        return scores;

    using (StreamReader lecteur = new StreamReader(cheminFichier))
    {
        while (!lecteur.EndOfStream)
        {
            string ligne = lecteur.ReadLine();
            string[] parties = ligne.Split(';');

            if (parties.Length == 2 && double.TryParse(parties[1], out double temps))
            {
                scores.Add((parties[0], temps));
            }
        }
    }

    return scores;
}
```

---

### 3ï¸âƒ£ Ã‰crire les scores (`StreamWriter`)

```csharp
private void EcrireScores(string cheminFichier, List<(string nom, double temps)> scores)
{
    using (StreamWriter ecrivain = new StreamWriter(cheminFichier, false))
    {
        foreach (var score in scores)
        {
            ecrivain.WriteLine($"{score.nom};{score.temps}");
        }
    }
}
```

---

### 4ï¸âƒ£ Mettre Ã  jour le Top 5

```csharp
private void MettreAJourTop5(string cheminFichier, double tempsPartie)
{
    List<(string nom, double temps)> scores = LireScores(cheminFichier);

    // VÃ©rifier si le score entre dans le Top 5
    if (scores.Count < 5 || tempsPartie < scores.Max(s => s.temps))
    {
        string nom = Microsoft.VisualBasic.Interaction.InputBox(
            "Nouveau meilleur temps ! Entrez votre nom :",
            "Nouveau score");

        if (string.IsNullOrWhiteSpace(nom))
        {
            nom = "Anonyme";
        }

        scores.Add((nom, tempsPartie));

        // Garder les 5 meilleurs temps (du plus petit au plus grand)
        scores = scores
            .OrderBy(s => s.temps)
            .Take(5)
            .ToList();

        EcrireScores(cheminFichier, scores);
    }
}
```

Ã€ la **victoire**, selon la difficultÃ© courante :

```csharp
string fichierScores = "scores_facile.txt";

if (gTailleGrille == DIFF_MOYEN_TAILLE)
    fichierScores = "scores_moyen.txt";
else if (gTailleGrille == DIFF_DIFFICILE_TAILLE)
    fichierScores = "scores_difficile.txt";

MettreAJourTop5(fichierScores, duree.TotalSeconds);
```

### âœ… RÃ©sultat attendu

- AprÃ¨s une **victoire**, si le temps est dans le Top 5 â†’ une petite fenÃªtre demande le **nom du joueur**.  
- Le fichier texte correspondant est crÃ©Ã©/ajustÃ©.  
- Les scores sont triÃ©s du meilleur au moins bon, limitÃ© Ã  5.

---

## Ã‰tape 8 â€” Afficher les meilleurs temps

### ğŸ¯ Objectif

Afficher une petite fenÃªtre contenant les meilleurs temps pour chaque difficultÃ©.

---

Dans le gestionnaire `afficherMeilleursTempsToolStripMenuItem_Click` :

```csharp
private void afficherMeilleursTempsToolStripMenuItem_Click(object sender, EventArgs e)
{
    string message = "=== Facile ===\n";
    var scoresFacile = LireScores("scores_facile.txt");
    foreach (var s in scoresFacile)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    message += "\n=== Moyen ===\n";
    var scoresMoyen = LireScores("scores_moyen.txt");
    foreach (var s in scoresMoyen)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    message += "\n=== Difficile ===\n";
    var scoresDifficile = LireScores("scores_difficile.txt");
    foreach (var s in scoresDifficile)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    MessageBox.Show(message, "Meilleurs temps");
}
```

### âœ… RÃ©sultat attendu

- Cliquer sur **Meilleurs temps** affiche une boÃ®te de dialogue listant les scores enregistrÃ©s pour chaque niveau.

---

# ğŸ§¾ Grille de correction â€“ TP4 : DÃ©mineur Windows Forms

:::danger âš ï¸â˜¢ï¸ğŸ”¥ ATTENTION!!!
**âš ï¸ Compilation obligatoire :**
- âœ… Le code compile : correction complÃ¨te selon les critÃ¨res ciâ€‘dessous.
- âŒ Le code **ne compile pas** : note maximale **60%**.
:::

---

## ğŸ” Ã‰valuation dÃ©taillÃ©e

:::note ğŸ¨ QualitÃ© de lâ€™interface graphique (Windows Forms) â€“ /30 points
- Utilisation appropriÃ©e des contrÃ´les Windows Forms (MenuStrip, boutonsâ€¦).
- Grille de boutons gÃ©nÃ©rÃ©e dynamiquement selon la difficultÃ©.
- Redimensionnement de la fenÃªtre en fonction de la taille de la grille.
- Interface claire, lisible et utilisable.
:::

:::note ğŸ§  Fonctionnement du jeu (logique, tableaux 2D) â€“ /45 points
- ReprÃ©sentation correcte du plateau avec des tableaux 2D.
- Placement correct des mines selon la difficultÃ©.
- Calcul correct du nombre de mines adjacentes.
- RÃ©vÃ©lation des cases cohÃ©rente (mine, nombre, case vide).
- DÃ©tection correcte de la fin de partie (victoire et dÃ©faite).
:::

:::note ğŸ’¾ Sauvegarde des meilleurs temps (fichiers) â€“ /25 points
- Utilisation de `StreamReader` et `StreamWriter`.
- Format de fichier cohÃ©rent et lisible.
- Enregistrement des **5 meilleurs temps** par difficultÃ©.
- Lecture et affichage corrects des scores.
- Demande du nom du joueur lors dâ€™un nouveau meilleur temps.
:::

---

:::note â­ Bonus â€“ Variante avancÃ©e (non rÃ©cursive) â€“ /5 points
- ImplÃ©mentation d'une ouverture de zone vide **itÃ©rative** (sans rÃ©cursivitÃ©).
- Utilisation d'une structure de donnÃ©es (par ex. `List<Point>`) pour gÃ©rer les cases Ã  traiter.
:::

### ğŸ’¯ Total : **100 points**

---

## âœ… Conseils

- Avance **Ã©tape par Ã©tape**, comme aux TP2 et TP3 : teste chaque nouvelle fonction via une mÃ©thode `Tests()`.  
- Commence par un seul niveau de difficultÃ© (Facile), puis ajoute les autres.  
- Garde une version fonctionnelle Ã  chaque Ã©tape (si nÃ©cessaire, commente le code incomplet).
