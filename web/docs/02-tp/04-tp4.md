# ğŸ§ª TP4 â€“ DÃ©mineur

---

## ğŸ¯ Objectif du TP4

RÃ©aliser un **jeu de DÃ©mineur** en **C# Windows Forms**.

Ce travail te fera passer de la console aux **interfaces graphiques (GUI)** tout en investissant les notions de tableaux 2D, de boucles, de conditions et de lecture/Ã©criture de fichiers.

### FonctionnalitÃ©s attendues
- **Menu** avec raccourcis clavier :
  - Cliquer sur **Nouvelle partie** dÃ©marre une nouvelle partie.  
  - Cliquer sur **Quitter** ferme l'application.  
- ğŸ§© **Grille de jeu** composÃ©e de boutons (une case = un bouton)
- ğŸšï¸ **Niveau de difficultÃ©** : **9 x 9** avec **10 mines**  
- ğŸ“‹ Barre de menu
- ğŸ“ **Redimensionnement automatique** de la fenÃªtre selon la taille de la grille

---

## ğŸ§‘â€ğŸ’» CrÃ©ation du projet Windows Forms

:::tip Note
CrÃ©er un projet **Application Windows Forms (.NET)**.

- Langage : **C#**  
- Nom du projet : par exemple `TP4_Demineur`
:::

## Ã‰tape 1 - PrÃ©parer la structure du projet

### ğŸ¯ Objectif

Mettre en place les **variables globales** et les premiers Ã©lÃ©ments nÃ©cessaires au DÃ©mineur :

- Les **tableaux 2D** pour reprÃ©senter le jeu
- Les constantes liÃ©es aux niveaux de difficultÃ©
- Une fonction `Tests()` pour vÃ©rifier progressivement le comportement du programme (comme aux TP2 et TP3).

---

### 1ï¸âƒ£ Variables globales et constantes

Ajouter dans ton fichier `Form1.cs` (Ã  lâ€™intÃ©rieur de la classe `Form1`, mais **en dehors** des mÃ©thodes) :

```csharp
// Taille de la grille et nombre de mines
const int COLONNES_GRILLE = 9;
const int LIGNES_GRILLE = 9;
const int NOMBRE_MINES = 10;

// Valeurs pour le contenu des cases
const int CASE_VIDE = 0;       // aucune mine autour
const int CASE_MINE = -1;      // case contenant une mine

// Grilles de jeu
int[,] grilleMines;           // contient mines / nombres
bool[,] grilleRevelee;        // indique si une case est rÃ©vÃ©lÃ©e
Button[,] grilleBoutons;      // boutons affichÃ©s Ã  l'Ã©cran
```

---

### 2ï¸âƒ£ MÃ©thode `Tests()`

Ajoute une mÃ©thode simple pour tester progressivement le contenu des tableaux.

```csharp
private void Tests()
{
    // Exemple : afficher quelques infos dans la console de sortie
    Console.WriteLine($"Taille : {colonnesGrille} x {lignesGrille}");
    Console.WriteLine($"Nombre de mines : {nombreMines}");
}
```

Appelle `Tests()` depuis le constructeur de `Form1` aprÃ¨s `InitializeComponent()` :

```csharp
public Form1()
{
    InitializeComponent();
    Tests();
}
```

:::tip OÃ¹ voir `Console.WriteLine` ?
Dans un projet Windows Forms, tu peux ouvrir la **fenÃªtre de sortie** de Visual Studio pour voir le texte envoyÃ© par `Console.WriteLine`.
:::

### âœ… RÃ©sultat attendu

- Le projet **compile** sans erreur.  
- Au dÃ©marrage, la fenÃªtre sâ€™ouvre et des informations de test sâ€™affichent dans la sortie.

---

## Ã‰tape 2 - CrÃ©er la barre de menu

### ğŸ¯ Objectif

Ajouter une **barre de menus** qui donnera accÃ¨s aux principales fonctionnalitÃ©s du jeu.

---

### 1ï¸âƒ£ Ajouter un `MenuStrip`

Dans le concepteur Windows Forms :

1. Glisser un contrÃ´le **`MenuStrip`** sur le formulaire.
2. Renommer-le (propriÃ©tÃ© `Name`) en `menuPrincipal`.
3. Ajouter les menus suivants :
   - `Jeu`
     - `Nouvelle partie` (raccourci : Ctrl+N)
     - `Quitter` (raccourci : Ctrl+Q)

Pour chaque Ã©lÃ©ment, tu peux double-cliquer pour gÃ©nÃ©rer un gestionnaire d'Ã©vÃ¨nement `Click`.

---

### 2ï¸âƒ£ Code minimal pour les menus

Exemple de **pseudo-code** pour les gestionnaires d'Ã©vÃ©nements dans `Form1` :

```text
Quand on clique sur "Nouvelle partie" :
    â†’ lancer l'initialisation de la grille et commencer une partie

Quand on clique sur "Quitter" :
    â†’ fermer la fenÃªtre principale de l'application
```

### âœ… RÃ©sultat attendu

- Cliquer sur **Nouvelle partie** affiche pour l'instant un comportement simple (par exemple un message) ou ne fait rien si la logique n'est pas encore codÃ©e.  
- Cliquer sur **Quitter** ferme l'application.

---

## Ã‰tape 3 - GÃ©nÃ©rer dynamiquement la grille de boutons

### ğŸ¯ Objectif

CrÃ©er une **grille de boutons** reprÃ©sentant le plateau du DÃ©mineur.

Chaque case du tableau correspond Ã  **un bouton** positionnÃ© dynamiquement sur le formulaire.

---

### ğŸ“š Notions importantes : Ajouter un contrÃ´le par le code

Dans Windows Forms, on peut crÃ©er et ajouter des contrÃ´les (boutons, labels, etc.) **dynamiquement depuis le code** plutÃ´t que depuis le concepteur visuel.

#### CrÃ©er et ajouter un bouton au formulaire

```csharp
int tailleBouton = 30;
int margeX = 10;
int margeY = 25;
// 1. CrÃ©er un nouveau bouton
Button monBouton = new Button();

// 2. Configurer ses propriÃ©tÃ©s
monBouton.Text = "";
monBouton.Width = tailleBouton;
monBouton.Height = tailleBouton;
monBouton.Location = new Point(tailleBouton*colonne+margeX, tailleBouton*ligne+margeY);  // Emplacement du bouton dans le formulaire

// 3. Brancher un Ã©vÃ©nement au clic
monBouton.Click += MonBouton_Click;

// 4. Ajouter le bouton au formulaire
this.Controls.Add(monBouton);
```

#### Utiliser la propriÃ©tÃ© `Tag` pour stocker des donnÃ©es

La propriÃ©tÃ© **`Tag`** permet d'associer n'importe quelle donnÃ©e Ã  un contrÃ´le. C'est trÃ¨s utile pour retrouver des informations lors d'un Ã©vÃ©nement (par exemple, savoir quelle case a Ã©tÃ© cliquÃ©e).

```csharp
// Stocker une position (x, y) dans le Tag
// ou position (ligne, colonne) du bouton
// le but Ã©tant de retrouver cette case dans la grille lors d'un clic
monBouton.Tag = new Point(x, y);
```

#### RÃ©cupÃ©rer le `Tag` lors d'un clic

```csharp
private void MonBouton_Click(object sender, EventArgs e)
{
    // RÃ©cupÃ©rer le bouton qui a dÃ©clenchÃ© l'Ã©vÃ©nement
    Button btn = (Button)sender;
    
    // RÃ©cupÃ©rer la position stockÃ©e dans le Tag
    Point position = (Point)btn.Tag;
    
    int x = position.X;
    int y = position.Y;
    
    MessageBox.Show($"Case cliquÃ©e : ({x}, {y})");
}
```

:::tip Pourquoi utiliser `Tag` ?
Quand on gÃ©nÃ¨re plusieurs boutons dans une boucle, ils partagent tous le mÃªme gestionnaire d'Ã©vÃ©nement. Le `Tag` permet de savoir **quel bouton prÃ©cis** a Ã©tÃ© cliquÃ© et d'agir en consÃ©quence.
:::

---

### 1ï¸âƒ£ PrÃ©parer une fonction `InitialiserGrille()`

Dans `Form1.cs` :

```text
Fonction InitialiserGrille :
    â†’ Initialiser grilleMines Ã  la bonne taille
    â†’ Initialiser grilleRevelee Ã  la bonne taille
    â†’ Initialiser grilleBoutons Ã  la bonne taille

    â†’ Effacer tous les contrÃ´les du formulaire
    â†’ RÃ©ajouter la barre de menu en haut

    â†’ DÃ©finir la taille d'une case en pixels (par ex. 30)
    â†’ DÃ©finir une marge autour de la grille (par ex. 10)

    Pour chaque ligne de 0 Ã  nombre de lignes - 1 :
        Pour chaque colonne de 0 Ã  nombre de colonnes - 1 :
            â†’ CrÃ©er un nouveau bouton
            â†’ Fixer sa largeur et sa hauteur Ã  la taille d'une case

            â†’ Calculer sa position en X en fonction de la colonne, de la taille de la case et de la marge
            â†’ Calculer sa position en Y en fonction de la ligne, de la taille de la case, de la marge et de la hauteur du menu

            â†’ Associer au bouton sa position (ligne, colonne) dans le Tag pour la retrouver lors du clic
            â†’ Brancher le gestionnaire d'Ã©vÃ©nement de clic (Bouton_Click)

            â†’ Ajouter le bouton sur le formulaire
            â†’ Ajouter le bouton Ã  grilleBoutons

    â†’ Ajuster la largeur de la fenÃªtre en fonction du nombre de colonnes et de la taille des cases
    â†’ Ajuster la hauteur de la fenÃªtre en fonction du nombre de lignes, de la taille des cases et de la hauteur du menu
```

Ajoute ensuite une mÃ©thode pour gÃ©rer le clic sur une case (en pseudoâ€‘code) :

```text
Quand on clique sur un bouton de la grille (Bouton_Click) :
    â†’ RÃ©cupÃ©rer la case cliquÃ©e (le bouton qui a envoyÃ© l'Ã©vÃ©nement)
    â†’ Lire, dans le Tag du bouton, la position (ligne, colonne)
    â†’ Pour lâ€™instant : afficher la position de la case cliquÃ©e sous la forme "(ligne, colonne)"
    â†’ (Ã  la prochaine Ã©tape) appeler une fonction qui rÃ©vÃ©lera la case dans la grille du dÃ©mineur
```

### âœ… RÃ©sultat attendu

- Cliquer sur **Nouvelle partie** â†’ la fenÃªtre affiche une grille de boutons 9x9.  
- Cliquer sur une case montre un message avec `(ligne, colonne)`.

---

## Ã‰tape 4 - Placer les mines et calculer les nombres

### ğŸ¯ Objectif

- Placer alÃ©atoirement les **mines** dans `grilleMines`.
- Calculer, pour chaque case non-mine, le **nombre de mines adjacentes**.

---

### 1ï¸âƒ£ Fonction `PlacerMines()`

```text
Fonction PlacerMines :
    â†’ Initialiser un compteur Â« minesPlacees Â» Ã  0

    Tant que Â« minesPlacees Â» est strictement infÃ©rieur Ã  Â« NOMBRE_MINES Â» :
        â†’ Choisir au hasard une ligne entre 0 et LIGNES_GRILLE - 1
        â†’ Choisir au hasard une colonne entre 0 et COLONNES_GRILLE - 1

        â†’ Si la case (ligne, colonne) ne contient pas dÃ©jÃ  une mine dans le tableau Â« grilleMines Â» :
            â†’ Placer une mine dans cette case (mettre CASE_MINE dans grilleMines[ligne, colonne])
            â†’ IncrÃ©menter Â« minesPlacees Â» de 1
```

---

### 2ï¸âƒ£ Fonction `CalculerNombreMines()`

Pour chaque case, on regarde les **8 voisins** autour dâ€™elle pour trouver le nombre de mines qui lui touche :

|         |  dc = -1  |   dc = 0   | dc = +1 |
|---------|----------:|-----------:|--------:|
| dl = -1 |  (-1,-1)  |   (-1,0)   |  (-1,1) |
| dl = 0  |  (-1,0)   |            |  (0,1)  |
| dl = +1 |  (-1,1)   |   (-1,1)   |  (1,1)  |

- `dl` â†’ DÃ©calage de ligne
- `dc` â†’ DÃ©calage de colonne
- `nl = ligne + dl` â†’ ligne voisine  
- `nc = colonne + dc` â†’ colonne voisine 

Exemple pour une case Ã  la position (4,2) on veut valider si le coin en haut Ã  gauche contient une mine
```csharp
ligne = 4;
colonne = 2;
dl = -1;
dc = -1;
nl = ligne + dl = 4 - 1 = 3;
nc = colonne + dc = 2 - 1 = 1;
```
On valider donc si (nl,nc) â†’ (3,1) contient une mine

On ne compte la case voisine que si `(nl, nc)` reste **dans les bornes du tableau**.
```text
Fonction CalculerNombreMines :

    Pour chaque ligne de 0 Ã  LIGNES_GRILLE - 1 :
        Pour chaque colonne de 0 Ã  COLONNES_GRILLE - 1 :

            â†’ Si la case (ligne, colonne) contient une mine dans grilleMines :
                  passer Ã  la case suivante (ne rien calculer pour cette case)

            â†’ Sinon :
                  initialiser un compteur Â« nbMines Â» Ã  0

                  Pour chaque dÃ©calage de ligne dl allant de -1 Ã  +1 :
                      Pour chaque dÃ©calage de colonne dc allant de -1 Ã  +1 :

                          â†’ si (dl, dc) vaut (0, 0), ignorer (câ€™est la case elleâ€‘mÃªme)

                          â†’ calculer nl = ligne + dl
                          â†’ calculer nc = colonne + dc

                          â†’ si (nl, nc) est Ã  lâ€™intÃ©rieur de la grille:
                                â†’ si la case (nl, nc) contient une mine dans grilleMines :
                                      augmenter Â« nbMines Â» de 1

                  â†’ aprÃ¨s avoir regardÃ© toutes les cases voisines,
                    enregistrer Â« nbMines Â» dans grilleMines[ligne, colonne]
```

---

### 3ï¸âƒ£ Mettre Ã  jour `InitialiserGrille()`

Ajouter les appels Ã  nos 2 fonctions et enregistrer l'heure de dÃ©but du jeu pour pouvoir calculer le temps.

```csharp
private void InitialiserGrille()
{
    //...

    PlacerMines();
    CalculerNombreMines();
    //...
}
```

### âœ… RÃ©sultat attendu

Ajoute ceci dans `Tests()` temporairement :

```csharp
InitialiserGrille();

string lignes = "";

for (int i = 0; i < LIGNES_GRILLE; i++)
{
    
    for (int j = 0; j < COLONNES_GRILLE; j++)
    {
        lignes += grilleMines[i, j].ToString().PadLeft(3);
    }
    lignes += "\r\n";
}

MessageBox.Show(lignes);
```

- Tu dois voir dans la fenÃªtre modal une **grille de nombres** :  
  - `-1` pour les mines  
  - `0,1,2,...` pour les nombres de mines adjacentes.

---

## Ã‰tape 5 - RÃ©vÃ©ler une case

### ğŸ¯ Objectif

- Quand on clique sur un bouton, rÃ©vÃ©ler la **valeur de la case** (mine, nombre, vide).  
- Marquer la case comme **rÃ©vÃ©lÃ©e** dans `grilleRevelee`.

---

### 1ï¸âƒ£ Fonction `RevelerCase(int ligne, int colonne)`

```text
Fonction RevelerCase(ligne, colonne) :
    â†’ Si la ligne ou la colonne est en dehors des limites de la grille :
          arrÃªter la fonction (return)
    
    â†’ Si la case (ligne, colonne) est dÃ©jÃ  rÃ©vÃ©lÃ©e dans grilleRevelee :
          arrÃªter la fonction (return)
    
    â†’ Marquer la case comme rÃ©vÃ©lÃ©e dans grilleRevelee[ligne, colonne]
    
    â†’ RÃ©cupÃ©rer le bouton qui vient d'Ãªtre cliquÃ© dans grilleBoutons
    
    â†’ Si il y a une mine sur la case :
            afficher "ğŸ’£" sur le bouton
            mettre le fond en rouge
            (la gestion de la dÃ©faite sera ajoutÃ©e Ã  l'Ã©tape suivante)
    
    â†’ Sinon, si la case est vide :
            ne rien afficher sur le bouton (Text = "")
            mettre le fond en gris clair
    
    â†’ Sinon (c'est un nombre) :
            afficher le nombre sur le bouton
            mettre le fond en blanc
```

### 2ï¸âƒ£ Utiliser `RevelerCase` dans `Bouton_Click`

```csharp
private void Bouton_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    Point position = (Point)btn.Tag;

    RevelerCase(position.X, position.Y);
}
```

```text
Fonction Bouton_RightClick(object sender, MouseEventArgs e) :

    â†’ Si le bouton de la souris nâ€™est PAS le clic droit (e.Button != MouseButtons.Right) :
          arrÃªter la fonction

    â†’ RÃ©cupÃ©rer le bouton cliquÃ©
    â†’ RÃ©cupÃ©rer la position (ligne, colonne)

    â†’ Si le texte du bouton est dÃ©jÃ  "ğŸš©" :
          â†’ enlever le drapeau
              btn.Text = ""
              remettre la couleur de fond par dÃ©faut (SystemColors.Control)

    â†’ Sinon (il nâ€™y a pas encore de drapeau) :
          â†’ ajouter un drapeau
              btn.Text = "ğŸš©"
              changer la couleur de fond (par ex. Color.LightSteelBlue)
```

### âœ… RÃ©sultat attendu

- Cliquer sur une case affiche :  
    - `ğŸ’£` sur un fond rouge (ou autre couleur selon vos goÃ»t) si câ€™est une mine  
    - un chiffre sur fond gris si câ€™est une case numÃ©rotÃ©e  
    - rien, `""`, (sur fond gris) si câ€™est vide.
- Le clic de droite sur une case affiche :
    - `ğŸš©` sur un fond de couleur s'il n'y avait pas dÃ©jÃ  un `ğŸš©`
    - Rien ("") et rÃ©tablit la couleur pas dÃ©faut du bouton (`SystemColors.Control`)


## Ã‰tape 6 - GÃ©rer la fin de partie (victoire / dÃ©faite)

### ğŸ¯ Objectif

- **Perdre** quand on clique sur une mine.  
- **Gagner** quand toutes les cases non-mines sont rÃ©vÃ©lÃ©es.

---

### 1ï¸âƒ£ DÃ©faite : clic sur une mine

- Modifie `RevelerCase` pour gÃ©rer la fin de partie si câ€™est une mine :
    - Afficher un message de dÃ©faite tel que "ğŸ’£â›ï¸ Oups c'Ã©tait une mine ! ğŸ’¥ "
    - Appeler `RevelerTout()` et terminer la partie

- CrÃ©e une fonction `RevelerTout` qui affichera toutes les cases de la grille lorsque l'on clique sur une mine :

```text
Fonction RevelerTout() :

    â†’ Pour chaque ligne de 0 Ã  LIGNES_GRILLE - 1 :
          Pour chaque colonne de 0 Ã  COLONNES_GRILLE - 1 :

              â†’ RÃ©cupÃ©rer le bouton correspondant dans grilleBoutons
              â†’ DÃ©sactiver le bouton

              â†’ Si la case contient une mine :
                    afficher "ğŸ’£" sur le bouton
                    mettre le fond en rouge (ou une autre couleur pour les mines non cliquÃ©es)

              â†’ Sinon, si la case est vide :
                    ne rien afficher (texte vide)
                    mettre le fond en gris clair

              â†’ Sinon (c'est un nombre) :
                    afficher le nombre sur le bouton
                    mettre le fond gris

              â†’ Marquer la case comme rÃ©vÃ©lÃ©e dans grilleRevelee[ligne, colonne]
```

---

### 2ï¸âƒ£ Victoire : toutes les cases non-mines rÃ©vÃ©lÃ©es

- Ajouter une fonction `VerifierVictoire()` :

```text
Fonction VerifierVictoire :

    Pour chaque ligne de 0 Ã  LIGNES_GRILLE - 1 :
        Pour chaque colonne de 0 Ã  COLONNES_GRILLE - 1 :

            â†’ Si la case (ligne, colonne) ne contient PAS une mine
              ET que la case n'est PAS rÃ©vÃ©lÃ©e dans grilleRevelee :

                  â†’ retourner faux (il reste encore au moins une case sÃ»re Ã  rÃ©vÃ©ler)
            â†’ Si la case (ligne, colonne) contient une mine
              ET que la case EST rÃ©vÃ©lÃ©e dans grilleRevelee :

                  â†’ retourner faux (Le joueur a rÃ©vÃ©lÃ© une mine, il a perdu)

    â†’ Si on a terminÃ© toutes les cases sans trouver de case sÃ»re non rÃ©vÃ©lÃ©e :
          retourner vrai (toutes les cases sans mine sont rÃ©vÃ©lÃ©es)
```

- Ajouter Ã  la fin de `RevelerCase` la vÃ©rification de la victoire:
- Afficher un message Ã  l'utilisateur et Initialiser une nouvelle partie

```text
â†’ Valider si c'est une victoire ou non avec `VerifierVictoire()`
â†’ Si c'est une victoire :
    â†’ Afficher un MessageBox.Show("ğŸ‰ Victoire !");
    â†’ DÃ©marrer une nouvelle partie
```

### âœ… RÃ©sultat attendu

- Clic sur une mine â†’ message de dÃ©faite + plus aucune rÃ©action aux clics.  
- RÃ©vÃ©ler toutes les cases sans mine â†’ message de victoire.

---

## Bonus - Ouverture en cascade des cases vides

### ğŸ¯ Objectif

Quand on clique sur une case **vide** (0 mines autour), on veut rÃ©vÃ©ler **automatiquement** toutes les cases vides voisines, ainsi que les nombres autour de cette zone (comme dans le vrai DÃ©mineur).

---

### 1ï¸âƒ£ Fonction rÃ©cursive `RevelerCase(int ligne, int colonne)`

- **Modifier `RevelerCase`** pour pouvoir rÃ©vÃ©ler une zone vide
- C'est sur le clic d'une case vide que nous pourrons rechercher les autres cases adjacentes vides
- Utiliser la rÃ©cursivitÃ© (une fonction qui s'appelle elle-mÃªme) pour afficher les cases vides voisines

```text
â†’ Sinon (la case est vide, CASE_VIDE) :
        â†’ Pour chaque voisin (dl de -1 Ã  +1, dc de -1 Ã  +1) :

            â†’ calculer nl = ligne + dl
            â†’ calculer nc = colonne + dc

            â†’ Appeler rÃ©cursivement RevelerCase(nl, nc)
```

Important :
- La **condition dâ€™arrÃªt** empÃªche la rÃ©cursion infinie :
  - hors de la grille â†’ on sâ€™arrÃªte
  - case dÃ©jÃ  rÃ©vÃ©lÃ©e â†’ on sâ€™arrÃªte
  - case non vide â†’ on sâ€™arrÃªte aprÃ¨s lâ€™avoir rÃ©vÃ©lÃ©e
- On ne propage la rÃ©cursion que depuis les **cases vides**.

---

### âœ… RÃ©sultat attendu (bonus rÃ©cursif)

- Clic sur une case vide â†’ toutes les cases vides connectÃ©es sont rÃ©vÃ©lÃ©es.
- Les **nombres autour** de la zone vide sont rÃ©vÃ©lÃ©s.
- Lâ€™algorithme utilise la **rÃ©cursivitÃ©** pour parcourir la zone

---

# ğŸ§¾ Grille de correction â€“ TP4 : DÃ©mineur

:::danger âš ï¸â˜¢ï¸ğŸ”¥ ATTENTION!!!
**âš ï¸ Compilation obligatoire :**
- âœ… Le code compile : correction complÃ¨te selon les critÃ¨res ciâ€‘dessous.
- âŒ Le code **ne compile pas** : note maximale **60%**.
:::

---

## ğŸ” Ã‰valuation dÃ©taillÃ©e

:::note ğŸ¨ QualitÃ© de l'interface graphique (Windows Forms) â€“ /40 points
- Utilisation appropriÃ©e des contrÃ´les Windows Forms (MenuStrip, boutonsâ€¦).
- Grille de boutons gÃ©nÃ©rÃ©e dynamiquement.
- Redimensionnement de la fenÃªtre en fonction de la taille de la grille.
- Interface claire, lisible et utilisable.
:::

:::note ğŸ§  Fonctionnement du jeu (logique, tableaux 2D) â€“ /60 points
- ReprÃ©sentation correcte du plateau avec des tableaux 2D.
- Placement correct des mines.
- Calcul correct du nombre de mines adjacentes.
- RÃ©vÃ©lation des cases cohÃ©rente (mine, nombre, case vide).
- DÃ©tection correcte de la fin de partie (victoire et dÃ©faite).
:::

---

:::note â­ Bonus â€“ /10 points
- ImplÃ©mentation d'une ouverture de zone vide.
:::

### ğŸ’¯ Total : **100 points**
