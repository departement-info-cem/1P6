# üß™ TP4 ‚Äì D√©mineur Windows Forms

---

## üéØ Objectif du TP4

R√©aliser un **jeu de D√©mineur** en **C# Windows Forms**.

Ce travail te fera passer de la console aux **interfaces graphiques (GUI)** tout en r√©investissant les notions de tableaux 2D, de boucles, de conditions et de lecture/√©criture de fichiers.

### Fonctionnalit√©s attendues

- üß© **Grille de jeu** compos√©e de boutons (une case = un bouton)
- üéöÔ∏è **Trois niveaux de difficult√©** :  
  - *Facile* ‚Üí **8 x 8** avec **10 mines**  
  - *Moyen* ‚Üí **12 x 12** avec **25 mines**  
  - *Difficile* ‚Üí **16 x 16** avec **80 mines**  
- üïí **Chronom√®tre** pour mesurer le temps de la partie
- üèÜ **Top 5 meilleurs temps** pour chaque niveau, sauvegard√©s dans un **fichier texte**
- üßæ **Fen√™tre de saisie du nom** lorsqu‚Äôun nouveau temps entre dans le **Top 5**
- üìÅ Lecture/√©criture des meilleurs scores avec `StreamReader` et `StreamWriter`
- üìã **Barre de menu** contenant au minimum :  
  - `Nouvelle partie` (**Ctrl+N**)  
  - `Quitter` (**Ctrl+Q**)  
  - `Difficult√©` ‚Üí *Facile*, *Moyen*, *Difficile*  
  - `Meilleurs temps` ‚Üí affiche les Top 5 pour chaque difficult√©
- üìê **Redimensionnement automatique** de la fen√™tre selon la taille de la grille (8x8, 12x12, 16x16)


---

## üßë‚Äçüíª Cr√©ation du projet Windows Forms

:::tip Note
Cr√©er un projet **Application Windows Forms (.NET)**.

- Langage : **C#**  
- Nom du projet : par exemple `TP4_Demineur`  
- Coche l‚Äôoption pour **ne pas utiliser les instructions de niveau sup√©rieur**, comme pour les autres TP.
:::


### ‚úÖ R√©sultat attendu

Une fen√™tre vide Windows Forms s‚Äôouvre avec un formulaire (`Form1`) pr√™t √† √™tre modifi√©.

---

## √âtape 1 ‚Äî Pr√©parer la structure du projet

### üéØ Objectif

Mettre en place les **variables globales** et les premiers √©l√©ments n√©cessaires au D√©mineur :

- Les **tableaux 2D** pour repr√©senter le jeu
- Les constantes li√©es aux niveaux de difficult√©
- Une fonction `Tests()` pour v√©rifier progressivement le comportement du programme (comme aux TP2 et TP3).

---

### 1Ô∏è‚É£ Variables globales et constantes

Ajouter dans ton fichier `Form1.cs` (√† l‚Äôint√©rieur de la classe `Form1`, mais **en dehors** des m√©thodes) :

```csharp
// Difficult√©s
const int DIFF_FACILE_TAILLE = 8;
const int DIFF_FACILE_MINES = 10;

const int DIFF_MOYEN_TAILLE = 12;
const int DIFF_MOYEN_MINES = 25;

const int DIFF_DIFFICILE_TAILLE = 16;
const int DIFF_DIFFICILE_MINES = 80;

// Valeurs pour le contenu des cases
const int CASE_VIDE = 0;       // aucune mine autour
const int CASE_MINE = -1;      // case contenant une mine

// Grilles de jeu
int[,] gGrilleMines;           // contient mines / nombres
bool[,] gGrilleRevelee;        // indique si une case est r√©v√©l√©e

// Param√®tres de la partie en cours
int gTailleGrille = DIFF_FACILE_TAILLE;
int gNombreMines = DIFF_FACILE_MINES;

// Chronom√®tre
DateTime gHeureDebut;
bool gPartieEnCours = false;

// G√©n√©rateur al√©atoire
Random gRandom = new Random();
```

---

### 2Ô∏è‚É£ M√©thode `Tests()`

Ajoute une m√©thode simple pour tester progressivement le contenu des tableaux.

```csharp
private void Tests()
{
    // Exemple : afficher quelques infos dans la console de sortie
    Console.WriteLine($"Taille : {gTailleGrille} x {gTailleGrille}");
    Console.WriteLine($"Nombre de mines : {gNombreMines}");
}
```

Appelle `Tests()` depuis le constructeur de `Form1` apr√®s `InitializeComponent()` :

```csharp
public Form1()
{
    InitializeComponent();
    Tests();
}
```

:::tip O√π voir `Console.WriteLine` ?
Dans un projet Windows Forms, tu peux ouvrir la **fen√™tre de sortie** de Visual Studio pour voir le texte envoy√© par `Console.WriteLine`.
:::

### ‚úÖ R√©sultat attendu

- Le projet **compile** sans erreur.  
- Au d√©marrage, la fen√™tre s‚Äôouvre et des informations de test s‚Äôaffichent dans la sortie.

---

## √âtape 2 ‚Äî Cr√©er la barre de menu

### üéØ Objectif

Ajouter une **barre de menus** qui donnera acc√®s aux principales fonctionnalit√©s du jeu.

---

### 1Ô∏è‚É£ Ajouter un `MenuStrip`

Dans le concepteur Windows Forms :

1. Glisser un contr√¥le **`MenuStrip`** sur le formulaire.
2. Renommer-le (propri√©t√© `Name`) en `menuPrincipal`.
3. Ajouter les menus suivants :
   - `Jeu`
     - `Nouvelle partie` (raccourci : Ctrl+N)
     - `Quitter` (raccourci : Ctrl+Q)
   - `Difficult√©`
     - `Facile`
     - `Moyen`
     - `Difficile`
   - `Meilleurs temps`
     - `Afficher les meilleurs temps`

Pour chaque √©l√©ment, tu peux double-cliquer pour g√©n√©rer un gestionnaire d‚Äô√©v√®nement `Click`.

---

### 2Ô∏è‚É£ Code minimal pour les menus

Exemple dans `Form1.cs` :

```csharp
private void nouvellePartieToolStripMenuItem_Click(object sender, EventArgs e)
{
    MessageBox.Show("Nouvelle partie ! (logique √† impl√©menter)");
}

private void quitterToolStripMenuItem_Click(object sender, EventArgs e)
{
    Close();
}

private void facileToolStripMenuItem_Click(object sender, EventArgs e)
{
    gTailleGrille = DIFF_FACILE_TAILLE;
    gNombreMines = DIFF_FACILE_MINES;
    MessageBox.Show("Difficult√© : Facile");
}

private void moyenToolStripMenuItem_Click(object sender, EventArgs e)
{
    gTailleGrille = DIFF_MOYEN_TAILLE;
    gNombreMines = DIFF_MOYEN_MINES;
    MessageBox.Show("Difficult√© : Moyen");
}

private void difficileToolStripMenuItem_Click(object sender, EventArgs e)
{
    gTailleGrille = DIFF_DIFFICILE_TAILLE;
    gNombreMines = DIFF_DIFFICILE_MINES;
    MessageBox.Show("Difficult√© : Difficile");
}

private void afficherMeilleursTempsToolStripMenuItem_Click(object sender, EventArgs e)
{
    MessageBox.Show("Affichage des meilleurs temps √† impl√©menter.");
}
```

### ‚úÖ R√©sultat attendu

- Cliquer sur **Nouvelle partie** affiche un message.  
- Cliquer sur **Quitter** ferme l‚Äôapplication.  
- Changer de difficult√© met √† jour `gTailleGrille` et `gNombreMines` et affiche un message de confirmation.

---

## √âtape 3 ‚Äî G√©n√©rer dynamiquement la grille de boutons

### üéØ Objectif

Cr√©er une **grille de boutons** repr√©sentant le plateau du D√©mineur.

Chaque case du tableau correspond √† **un bouton** positionn√© dynamiquement sur le formulaire.

---

### 1Ô∏è‚É£ Pr√©parer une fonction `CreerGrilleBoutons()`

Dans `Form1.cs` :

```csharp
private void CreerGrilleBoutons()
{
    // Nettoyer les anciens boutons
    this.Controls.Clear();
    this.Controls.Add(menuPrincipal); // R√©ajouter le menu

    int tailleCase = 30; // pixels
    int marge = 10;      // marge autour de la grille

    for (int ligne = 0; ligne < gTailleGrille; ligne++)
    {
        for (int colonne = 0; colonne < gTailleGrille; colonne++)
        {
            Button btnCase = new Button();
            btnCase.Width = tailleCase;
            btnCase.Height = tailleCase;

            // Position de la case gr√¢ce √† un Point(x, y)
            btnCase.Location = new Point(
                marge + colonne * tailleCase,
                menuPrincipal.Height + marge + ligne * tailleCase
            );

            // On stocke la position dans Tag pour la retrouver au clic
            btnCase.Tag = new Point(ligne, colonne);

            btnCase.Click += BoutonCase_Click;

            this.Controls.Add(btnCase);
        }
    }

    // Ajuster la taille de la fen√™tre
    this.Width = marge * 2 + gTailleGrille * tailleCase + 20;
    this.Height = menuPrincipal.Height + marge * 2 + gTailleGrille * tailleCase + 40;
}
```

Ajoute une m√©thode pour g√©rer le clic sur une case :

```csharp
private void BoutonCase_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    Point position = (Point)btn.Tag;

    int ligne = position.X;
    int colonne = position.Y;

    MessageBox.Show($"Clic sur la case ({ligne}, {colonne})");
}
```

---

### 2Ô∏è‚É£ Appeler `CreerGrilleBoutons()`

Dans le gestionnaire de menu `Nouvelle partie` :

```csharp
private void nouvellePartieToolStripMenuItem_Click(object sender, EventArgs e)
{
    InitialiserGrille();   // m√©thode √† cr√©er √† l‚Äô√©tape suivante
    CreerGrilleBoutons();
}
```

Pour l‚Äôinstant, cr√©e une version minimale de `InitialiserGrille()` :

```csharp
private void InitialiserGrille()
{
    gGrilleMines = new int[gTailleGrille, gTailleGrille];
    gGrilleRevelee = new bool[gTailleGrille, gTailleGrille];
}
```

### ‚úÖ R√©sultat attendu

- Cliquer sur **Nouvelle partie** ‚Üí la fen√™tre affiche une grille de boutons en fonction de la difficult√©.  
- La taille de la fen√™tre **change** correctement si tu passes de *Facile* √† *Difficile* (8x8 ‚Üí 16x16).  
- Cliquer sur une case montre un message avec `(ligne, colonne)`.

---

## √âtape 4 ‚Äî Placer les mines et calculer les nombres

### üéØ Objectif

- Placer al√©atoirement les **mines** dans `gGrilleMines`.
- Calculer, pour chaque case non-mine, le **nombre de mines adjacentes**.

---

### 1Ô∏è‚É£ Fonction `PlacerMines()`

```csharp
private void PlacerMines()
{
    int minesPlacees = 0;

    while (minesPlacees < gNombreMines)
    {
        int ligne = gRandom.Next(0, gTailleGrille);
        int colonne = gRandom.Next(0, gTailleGrille);

        if (gGrilleMines[ligne, colonne] != CASE_MINE)
        {
            gGrilleMines[ligne, colonne] = CASE_MINE;
            minesPlacees++;
        }
    }
}
```

---

### 2Ô∏è‚É£ Fonction `CalculerNombres()`

```csharp
private void CalculerNombres()
{
    for (int ligne = 0; ligne < gTailleGrille; ligne++)
    {
        for (int colonne = 0; colonne < gTailleGrille; colonne++)
        {
            if (gGrilleMines[ligne, colonne] == CASE_MINE)
                continue;

            int compte = 0;

            // Parcourir les 8 cases autour
            for (int dl = -1; dl <= 1; dl++)
            {
                for (int dc = -1; dc <= 1; dc++)
                {
                    if (dl == 0 && dc == 0) continue;

                    int nl = ligne + dl;
                    int nc = colonne + dc;

                    if (nl >= 0 && nl < gTailleGrille && nc >= 0 && nc < gTailleGrille)
                    {
                        if (gGrilleMines[nl, nc] == CASE_MINE)
                        {
                            compte++;
                        }
                    }
                }
            }

            gGrilleMines[ligne, colonne] = compte;
        }
    }
}
```

---

### 3Ô∏è‚É£ Mettre √† jour `InitialiserGrille()`

```csharp
private void InitialiserGrille()
{
    gGrilleMines = new int[gTailleGrille, gTailleGrille];
    gGrilleRevelee = new bool[gTailleGrille, gTailleGrille];

    PlacerMines();
    CalculerNombres();

    gPartieEnCours = true;
    gHeureDebut = DateTime.Now;
}
```

### ‚úÖ R√©sultat attendu

Ajoute ceci dans `Tests()` temporairement :

```csharp
InitialiserGrille();

for (int i = 0; i < gTailleGrille; i++)
{
    string ligne = "";
    for (int j = 0; j < gTailleGrille; j++)
    {
        ligne += gGrilleMines[i, j].ToString().PadLeft(3);
    }
    Console.WriteLine(ligne);
}
```

- Tu dois voir dans la sortie une **grille de nombres** :  
  - `-1` pour les mines  
  - `0,1,2,...` pour les nombres de mines adjacentes.

---

## √âtape 5 ‚Äî R√©v√©ler une case (logique de base)

### üéØ Objectif

- Quand on clique sur un bouton, r√©v√©ler la **valeur de la case** (mine, nombre, vide).  
- Marquer la case comme **r√©v√©l√©e** dans `gGrilleRevelee`.
- Quand on clique sur une **case vide (0)**, r√©v√©ler automatiquement **toutes les cases vides adjacentes** ainsi que les **nombres qui les bordent**, comme dans le D√©mineur classique (voir l‚Äôillustration donn√©e en exemple).

---

### 1Ô∏è‚É£ Fonction `RevelerCase(int ligne, int colonne)`

```csharp
private void RevelerCase(int ligne, int colonne)
{
    if (!gPartieEnCours)
        return;

    if (ligne < 0 || ligne >= gTailleGrille || colonne < 0 || colonne >= gTailleGrille)
        return;

    if (gGrilleRevelee[ligne, colonne])
        return;

    gGrilleRevelee[ligne, colonne] = true;

    // Retrouver le bouton correspondant
    foreach (Control ctrl in this.Controls)
    {
        if (ctrl is Button btn && btn.Tag is Point p)
        {
            if (p.X == ligne && p.Y == colonne)
            {
                if (gGrilleMines[ligne, colonne] == CASE_MINE)
                {
                    btn.Text = "üí£";
                    btn.BackColor = Color.Red;
                    // La gestion de la d√©faite sera ajout√©e √† l'√©tape suivante
                }
                else if (gGrilleMines[ligne, colonne] == CASE_VIDE)
                {
                    btn.Text = "";
                    btn.BackColor = Color.LightGray;

                    // R√©v√©lation en cascade : on r√©v√®le aussi les cases autour
                    for (int dl = -1; dl <= 1; dl++)
                    {
                        for (int dc = -1; dc <= 1; dc++)
                        {
                            if (dl == 0 && dc == 0)
                                continue;

                            int nl = ligne + dl;
                            int nc = colonne + dc;

                            // Appel r√©cursif pour les cases voisines
                            RevelerCase(nl, nc);
                        }
                    }
                }
                else
                {
                    btn.Text = gGrilleMines[ligne, colonne].ToString();
                    btn.BackColor = Color.White;
                }
            }
        }
    }
}
```

---

### 2Ô∏è‚É£ Utiliser `RevelerCase` dans `BoutonCase_Click`

```csharp
private void BoutonCase_Click(object sender, EventArgs e)
{
    Button btn = (Button)sender;
    Point position = (Point)btn.Tag;

    RevelerCase(position.X, position.Y);
}
```

### ‚úÖ R√©sultat attendu

- Cliquer sur une case affiche :  
    - `üí£` si c‚Äôest une mine  
    - un chiffre si c‚Äôest une case num√©rot√©e  
    - rien (fond gris) si c‚Äôest vide (`0`).
- Si tu cliques sur une **zone vide**, toutes les cases vides connect√©es et les **nombres adjacents** sont r√©v√©l√©s automatiquement, formant une ¬´ ouverture ¬ª comme dans le D√©mineur classique (voir l‚Äôimage d‚Äôexemple du TP).

:::info Variante optionnelle ‚Äì Version non r√©cursive
Pour √©viter la r√©cursivit√©, on peut aussi utiliser une petite **liste de cases √† traiter** (approche it√©rative) :

```csharp
private void RevelerZoneVide(int ligneDepart, int colonneDepart)
{
    List<Point> aTraiter = new List<Point>();
    aTraiter.Add(new Point(ligneDepart, colonneDepart));

    while (aTraiter.Count > 0)
    {
        Point courant = aTraiter[aTraiter.Count - 1];
        aTraiter.RemoveAt(aTraiter.Count - 1);

        int ligne = courant.X;
        int colonne = courant.Y;

        if (ligne < 0 || ligne >= gTailleGrille || colonne < 0 || colonne >= gTailleGrille)
            continue;

        if (gGrilleRevelee[ligne, colonne])
            continue;

        gGrilleRevelee[ligne, colonne] = true;

        // Mettre √† jour l'affichage du bouton correspondant
        foreach (Control ctrl in this.Controls)
        {
            if (ctrl is Button btn && btn.Tag is Point p && p.X == ligne && p.Y == colonne)
            {
                if (gGrilleMines[ligne, colonne] == CASE_VIDE)
                {
                    btn.Text = "";
                    btn.BackColor = Color.LightGray;
                }
                else if (gGrilleMines[ligne, colonne] > CASE_VIDE)
                {
                    btn.Text = gGrilleMines[ligne, colonne].ToString();
                    btn.BackColor = Color.White;
                }
                break;
            }
        }

        // Si la case est vide, on ajoute ses voisins non r√©v√©l√©s
        if (gGrilleMines[ligne, colonne] == CASE_VIDE)
        {
            for (int dl = -1; dl <= 1; dl++)
            {
                for (int dc = -1; dc <= 1; dc++)
                {
                    if (dl == 0 && dc == 0)
                        continue;

                    int nl = ligne + dl;
                    int nc = colonne + dc;

                    if (nl >= 0 && nl < gTailleGrille && nc >= 0 && nc < gTailleGrille)
                    {
                        if (!gGrilleRevelee[nl, nc] && gGrilleMines[nl, nc] != CASE_MINE)
                        {
                            aTraiter.Add(new Point(nl, nc));
                        }
                    }
                }
            }
        }
    }
}
```

Et dans `RevelerCase` :

```csharp
else if (gGrilleMines[ligne, colonne] == CASE_VIDE)
{
    RevelerZoneVide(ligne, colonne);
}
```
:::

---

## √âtape 6 ‚Äî G√©rer la fin de partie (victoire / d√©faite)

### üéØ Objectif

- **Perdre** quand on clique sur une mine.  
- **Gagner** quand toutes les cases non-mines sont r√©v√©l√©es.

---

### 1Ô∏è‚É£ D√©faite : clic sur une mine

Modifie `RevelerCase` pour g√©rer la fin de partie si c‚Äôest une mine :

```csharp
if (gGrilleMines[ligne, colonne] == CASE_MINE)
{
    btn.Text = "üí£";
    btn.BackColor = Color.Red;
    gPartieEnCours = false;

    MessageBox.Show("üí• BOOM ! Vous avez perdu.");
    return;
}
```

---

### 2Ô∏è‚É£ Victoire : toutes les cases non-mines r√©v√©l√©es

Ajoute une fonction :

```csharp
private bool ToutesCasesNonMinesRevelees()
{
    for (int ligne = 0; ligne < gTailleGrille; ligne++)
    {
        for (int colonne = 0; colonne < gTailleGrille; colonne++)
        {
            if (gGrilleMines[ligne, colonne] != CASE_MINE && !gGrilleRevelee[ligne, colonne])
            {
                return false;
            }
        }
    }
    return true;
}
```

√Ä la fin de `RevelerCase` (si ce n‚Äôest pas une mine) :

```csharp
if (ToutesCasesNonMinesRevelees())
{
    gPartieEnCours = false;
    TimeSpan duree = DateTime.Now - gHeureDebut;
    MessageBox.Show($"üéâ Victoire ! Temps : {duree.TotalSeconds:F1} secondes");

    // Sauvegarde du score √† l‚Äô√©tape suivante
}
```

### ‚úÖ R√©sultat attendu

- Clic sur une mine ‚Üí message de d√©faite + plus aucune r√©action aux clics.  
- R√©v√©ler toutes les cases sans mine ‚Üí message de victoire avec le temps.

---

## √âtape 7 ‚Äî Sauvegarder les meilleurs temps

### üéØ Objectif

- Sauvegarder les **5 meilleurs temps** par niveau de difficult√© dans un **fichier texte**.  
- Lire ce fichier au d√©marrage.  
- Demander le **nom du joueur** quand un nouveau temps entre dans le Top 5.

---

### 1Ô∏è‚É£ Format des fichiers

Tu peux cr√©er un fichier par difficult√©, par exemple :

- `scores_facile.txt`
- `scores_moyen.txt`
- `scores_difficile.txt`

Format propos√© (un score par ligne) :

```text
NomJoueur;TempsEnSecondes
Alice;35,4
Bob;42,8
```

---

### 2Ô∏è‚É£ Lire les scores (`StreamReader`)

```csharp
private List<(string nom, double temps)> LireScores(string cheminFichier)
{
    List<(string nom, double temps)> scores = new List<(string nom, double temps)>();

    if (!File.Exists(cheminFichier))
        return scores;

    using (StreamReader lecteur = new StreamReader(cheminFichier))
    {
        while (!lecteur.EndOfStream)
        {
            string ligne = lecteur.ReadLine();
            string[] parties = ligne.Split(';');

            if (parties.Length == 2 && double.TryParse(parties[1], out double temps))
            {
                scores.Add((parties[0], temps));
            }
        }
    }

    return scores;
}
```

---

### 3Ô∏è‚É£ √âcrire les scores (`StreamWriter`)

```csharp
private void EcrireScores(string cheminFichier, List<(string nom, double temps)> scores)
{
    using (StreamWriter ecrivain = new StreamWriter(cheminFichier, false))
    {
        foreach (var score in scores)
        {
            ecrivain.WriteLine($"{score.nom};{score.temps}");
        }
    }
}
```

---

### 4Ô∏è‚É£ Mettre √† jour le Top 5

```csharp
private void MettreAJourTop5(string cheminFichier, double tempsPartie)
{
    List<(string nom, double temps)> scores = LireScores(cheminFichier);

    // V√©rifier si le score entre dans le Top 5
    if (scores.Count < 5 || tempsPartie < scores.Max(s => s.temps))
    {
        string nom = Microsoft.VisualBasic.Interaction.InputBox(
            "Nouveau meilleur temps ! Entrez votre nom :",
            "Nouveau score");

        if (string.IsNullOrWhiteSpace(nom))
        {
            nom = "Anonyme";
        }

        scores.Add((nom, tempsPartie));

        // Garder les 5 meilleurs temps (du plus petit au plus grand)
        scores = scores
            .OrderBy(s => s.temps)
            .Take(5)
            .ToList();

        EcrireScores(cheminFichier, scores);
    }
}
```

√Ä la **victoire**, selon la difficult√© courante :

```csharp
string fichierScores = "scores_facile.txt";

if (gTailleGrille == DIFF_MOYEN_TAILLE)
    fichierScores = "scores_moyen.txt";
else if (gTailleGrille == DIFF_DIFFICILE_TAILLE)
    fichierScores = "scores_difficile.txt";

MettreAJourTop5(fichierScores, duree.TotalSeconds);
```

### ‚úÖ R√©sultat attendu

- Apr√®s une **victoire**, si le temps est dans le Top 5 ‚Üí une petite fen√™tre demande le **nom du joueur**.  
- Le fichier texte correspondant est cr√©√©/ajust√©.  
- Les scores sont tri√©s du meilleur au moins bon, limit√© √† 5.

---

## √âtape 8 ‚Äî Afficher les meilleurs temps

### üéØ Objectif

Afficher une petite fen√™tre contenant les meilleurs temps pour chaque difficult√©.

---

Dans le gestionnaire `afficherMeilleursTempsToolStripMenuItem_Click` :

```csharp
private void afficherMeilleursTempsToolStripMenuItem_Click(object sender, EventArgs e)
{
    string message = "=== Facile ===\n";
    var scoresFacile = LireScores("scores_facile.txt");
    foreach (var s in scoresFacile)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    message += "\n=== Moyen ===\n";
    var scoresMoyen = LireScores("scores_moyen.txt");
    foreach (var s in scoresMoyen)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    message += "\n=== Difficile ===\n";
    var scoresDifficile = LireScores("scores_difficile.txt");
    foreach (var s in scoresDifficile)
    {
        message += $"{s.nom} : {s.temps:F1} s\n";
    }

    MessageBox.Show(message, "Meilleurs temps");
}
```

### ‚úÖ R√©sultat attendu

- Cliquer sur **Meilleurs temps** affiche une bo√Æte de dialogue listant les scores enregistr√©s pour chaque niveau.

---

# üßæ Grille de correction ‚Äì TP4 : D√©mineur Windows Forms

:::danger ‚ö†Ô∏è‚ò¢Ô∏èüî• ATTENTION!!!
**‚ö†Ô∏è Compilation obligatoire :**
- ‚úÖ Le code compile : correction compl√®te selon les crit√®res ci‚Äëdessous.
- ‚ùå Le code **ne compile pas** : note maximale **60%**.
:::

---

## üîç √âvaluation d√©taill√©e

:::note üé® Qualit√© de l‚Äôinterface graphique (Windows Forms) ‚Äì /30 points
- Utilisation appropri√©e des contr√¥les Windows Forms (MenuStrip, boutons‚Ä¶).
- Grille de boutons g√©n√©r√©e dynamiquement selon la difficult√©.
- Redimensionnement de la fen√™tre en fonction de la taille de la grille.
- Interface claire, lisible et utilisable.
:::

:::note üß† Fonctionnement du jeu (logique, tableaux 2D) ‚Äì /45 points
- Repr√©sentation correcte du plateau avec des tableaux 2D.
- Placement correct des mines selon la difficult√©.
- Calcul correct du nombre de mines adjacentes.
- R√©v√©lation des cases coh√©rente (mine, nombre, case vide).
- D√©tection correcte de la fin de partie (victoire et d√©faite).
:::

:::note üíæ Sauvegarde des meilleurs temps (fichiers) ‚Äì /25 points
- Utilisation de `StreamReader` et `StreamWriter`.
- Format de fichier coh√©rent et lisible.
- Enregistrement des **5 meilleurs temps** par difficult√©.
- Lecture et affichage corrects des scores.
- Demande du nom du joueur lors d‚Äôun nouveau meilleur temps.
:::

---

:::note ‚≠ê Bonus ‚Äì Variante avanc√©e (non r√©cursive) ‚Äì /5 points
- Impl√©mentation d'une ouverture de zone vide **it√©rative** (sans r√©cursivit√©).
- Utilisation d'une structure de donn√©es (par ex. `List<Point>`) pour g√©rer les cases √† traiter.
:::

### üíØ Total : **100 points**

---

## ‚úÖ Conseils

- Avance **√©tape par √©tape**, comme aux TP2 et TP3 : teste chaque nouvelle fonction via une m√©thode `Tests()`.  
- Commence par un seul niveau de difficult√© (Facile), puis ajoute les autres.  
- Garde une version fonctionnelle √† chaque √©tape (si n√©cessaire, commente le code incomplet).
